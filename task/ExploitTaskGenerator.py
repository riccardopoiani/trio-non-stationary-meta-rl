import torch
import numpy as np
from task.TaskGenerator import TaskGenerator


class ExploitTaskGenerator(TaskGenerator):

    def __init__(self, theta_min, theta_max, noise_var):
        self.noise_var = noise_var
        self.theta_min = theta_min
        self.theta_max = theta_max

        self.data_set = None
        self.param = None
        self.prior_dist = None
        self.n_tasks = None

    def sample_task_from_prior(self, prior):
        mu = prior[0].clone().detach()
        var = prior[1].clone().detach()

        task_param = torch.normal(mu, var)

        envs_kwargs = {'noise_var': self.noise_var,
                       'theta': task_param.item(),
                       }

        return envs_kwargs

    def sample_pair_tasks(self, num_processes):
        # Choose pair of init task and distribution for the next task
        task_idx = torch.randint(low=0, high=self.n_tasks, size=(num_processes,))
        new_tasks = torch.tensor([self.param[i] for i in task_idx]).reshape(num_processes, 1)

        prior_idx = torch.randint(low=0, high=self.n_tasks, size=(num_processes,))
        prior = [self.prior_dist[prior_idx[i]].clone().detach() for i in range(num_processes)]

        envs_kwargs = [{'noise_var': self.noise_var,
                        'theta': new_tasks[i].item()
                        } for i in range(num_processes)]

        return envs_kwargs, None, prior, new_tasks

    def create_task_family(self, n_tasks, n_batches=1, test_perc=0, batch_size=160):
        data_set = []
        param = []

        for _ in range(n_tasks):
            data, mean = self._create_family_item(n_batches=n_batches, test_perc=test_perc, batch_size=batch_size)
            data_set.append(data)
            param.append((mean.item()))

        prior_dist = []
        for _ in range(n_tasks):
            prior_dist.append(torch.Tensor(self._sample_prior()))

        self.data_set = data_set
        self.param = param
        self.prior_dist = prior_dist
        self.n_tasks = n_tasks

        return data_set, param, prior_dist

    def _create_family_item(self, n_batches, test_perc=0, batch_size=128):
        # m = (self.theta_min - self.theta_max) * torch.rand(1) + self.theta_max
        if np.random.binomial(n=1, p=0.5):
            m = 0.1
        else:
            m = -0.1

        return None, torch.tensor([m], dtype=torch.float32)

    def _sample_prior(self):
        mu_l = []
        std_l = []

        mu = torch.tensor([0], dtype=torch.float32)
        std = torch.tensor([0.1], dtype=torch.float32)

        mu_l.append(mu)
        std_l.append(std)

        return mu_l, std_l
